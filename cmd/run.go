package cmd

import (
	"context"
	"fmt"
	"log"
	"os"
	"path/filepath"

	"github.com/pulumi/pulumi-tool-cdk-importer/internal/common"
	"github.com/pulumi/pulumi-tool-cdk-importer/internal/lookups"
	"github.com/pulumi/pulumi-tool-cdk-importer/internal/proxy"
)

const (
	defaultImportFileName = "import.json"
	// Iteration defaults to keeping the local backend in a predictable location for reuse.
	defaultLocalStackFile = ".pulumi/import-state.json"
)

type runConfig struct {
	mode             proxy.RunMode
	stacks           []string
	importFile       string
	skipCreate       bool
	keepImportState  bool
	localStackFile   string
	workDir          string
	invocationDir    string
	usePreviewImport bool
	verbose          int
}

func run(cfg runConfig) error {
	if err := validateConfig(cfg); err != nil {
		return err
	}

	logger := log.New(os.Stdout, "[cdk-importer] ", log.Ltime|log.Lshortfile)
	ctx := context.Background()

	if err := os.Chdir(cfg.workDir); err != nil {
		return fmt.Errorf("failed to change directory to program: %w", err)
	}

	cc, err := lookups.NewDefaultLookups(ctx)
	if err != nil {
		return fmt.Errorf("failed to initialize AWS clients (set AWS_REGION or AWS_DEFAULT_REGION if not already configured): %w", err)
	}

	for _, stackRef := range cfg.stacks {
		stackName := common.StackName(stackRef)
		logger.Printf("Getting stack resources for stack: %s", stackName)
		// NOTE: CfnStackResources is keyed only by logical ID, so later stacks
		// can overwrite earlier ones if names collide. We assume overlaps are rare
		// across stacks generated by the same CDK app. TODO: Revisit if collisions
		// show up in the wild and namespace by stack.
		if err := cc.GetStackResources(ctx, stackName); err != nil {
			return err
		}
	}

	mode := cfg.mode
	importPath := cfg.importFile
	if importPath == "" && mode == proxy.CaptureImports {
		importPath = resolvePath(cfg.invocationDir, defaultImportFileName)
	}
	skipCreateMode := cfg.skipCreate
	keepState := cfg.keepImportState
	localStack := cfg.localStackFile

	if mode == proxy.CaptureImports {
		skipCreateMode = true
		keepState = true
		if localStack == "" {
			localStack = resolvePath(cfg.invocationDir, defaultLocalStackFile)
		}
	}

	options := proxy.RunOptions{
		Mode:             mode,
		ImportFilePath:   importPath,
		SkipCreate:       skipCreateMode,
		KeepImportState:  keepState,
		LocalStackFile:   localStack,
		StackNames:       cfg.stacks,
		Verbose:          cfg.verbose,
		UsePreviewImport: cfg.usePreviewImport || importPath != "",
	}

	return proxy.RunPulumiUpWithProxies(ctx, logger, cc, ".", options)
}

func validateConfig(cfg runConfig) error {
	if len(cfg.stacks) == 0 {
		return fmt.Errorf("stack is required")
	}
	if cfg.workDir == "" {
		return fmt.Errorf("program directory is required")
	}
	if cfg.mode == proxy.RunPulumi {
		if cfg.keepImportState {
			return fmt.Errorf("--keep-import-state is only supported in iterate mode")
		}
		if cfg.localStackFile != "" {
			return fmt.Errorf("--local-stack-file is only supported in iterate mode")
		}
	}
	return nil
}

func resolvePath(baseDir, path string) string {
	if path == "" {
		return ""
	}
	if filepath.IsAbs(path) {
		return path
	}
	return filepath.Join(baseDir, path)
}
