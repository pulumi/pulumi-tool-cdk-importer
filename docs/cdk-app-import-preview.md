# Import File Capture via Engine Events

This document tracks the current capture flow used by `program iterate`: seed an
import file from Pulumi engine resource registration events, then enrich it with
intercepted metadata and exported state. The older `--cdk-app` in-process synthesis
flow has been removed; we now assume an existing Pulumi program (for example, one
you generated with cdk2pulumi ahead of time).

## Goals

- Emit an import file that contains every resource reachable from the Pulumi
  program under test.
- Leverage Pulumi engine `ResourcePreEvent` (register/step metadata) to produce
  the base skeleton so we get full coverage even if some resources fail later.
- Enrich the generated skeleton with any IDs/inputs we can infer from
  intercepted provider calls and exported state so users start with a
  mostly-complete manifest.
- Keep the workflow contained: temporary backend, no mutations to user stacks,
  and optional validation reruns.

## Assumptions / Pre-Reqs

- We have an existing Pulumi program to run (e.g., generated by cdk2pulumi
  separately).
- AWS credentials and config needed for the run are available.
- A stack backend is available (use local backend machinery we already have for
  capture mode).
- Engine `ResourcePreEvent` is emitted for every registered resource (even when
  later steps fail), giving us coverage independent of preview success.

## Flow

1) **Program ready**: user supplies an existing Pulumi program and we `chdir`
   into it.
2) **Backend prep**: ensure we use a local backend/stack (reuse
   `--local-stack-file`/`--keep-import-state` plumbing). Create or reuse the
   stack in that backend.
3) **Load skeleton (optional)**: if an existing `import.json` is present at the
   requested path, read it and treat it as the authoritative starting point
   (preserving user-provided values/IDs).
4) **Seed skeleton**: while running `pulumi up`, collect `ResourcePreEvent`s and
   build a skeleton resource list (with `<PLACEHOLDER>` IDs). Merge this skeleton
   into the existing file (if any), adding missing resources without overwriting
   user edits.
5) **Enrichment pass**: walk exported state and captured provider metadata to
   fill:
   - Resource IDs we can derive (ARNs, names), preferring captured IDs (the
     ones actually used for import) over exported state IDs.
   - Component flags and provider versions from state.
   - Logical names and versions if needed.
   - Leave `<PLACEHOLDER>` where unknown; optionally attach `Notes`/metadata
     explaining what is needed.
6) **Write enriched file**: overwrite the same `import.json` (or a
   user-specified path) with the merged data.
7) **Cleanup**: delete the temp backend unless `--keep-import-state` is set.

## Data Mapping Notes

- Use the Pulumi-generated entries as the canonical resource list; if we cannot
  map a CFN resource to a Pulumi entry, log a warning.
- Prefer state-derived parent info from the preview output; fill gaps from our
  own mappings when placeholder/missing.
- Keep `NameTable` generation consistent with the capture-mode path; merge
  rather than replace if Pulumi adds entries.
- Preserve any Pulumi-added fields verbatim to avoid schema drift. Do not inject
  provider names; only retain versions.

## Error Handling

- Always write an import file, even when `pulumi up` fails, so users can iterate.
- Guard the enrichment step with schema validation to avoid writing malformed JSON.

## Testing Plan (minimum)

- Unit: ensure we register resources via engine events and seed skeleton entries.
- Unit: verify enrichment fills derivable IDs for known resource types and preserves `<PLACEHOLDER>` otherwise.
- Integration (happy path): run against `integration/cdk-test` to confirm `import.json` is emitted and enriched.

## Open Questions

- Do we need a knob to skip the enrichment pass and leave the Pulumi-generated
  placeholders untouched?
- Should we write the skeleton and enriched outputs to separate files (e.g.,
  `import.skeleton.json` and `import.json`) for debugging?
- Are there provider types where preview will not produce entries we expect
  (custom providers, policy packs)?
